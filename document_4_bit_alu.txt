4-Bit Modular ALU — Verilog Project Documentation
1. Introduction
1.1 Project Overview

To design, implement, and verify a 4-bit Arithmetic Logic Unit (ALU) in Verilog HDL.
The ALU performs arithmetic, logical, and comparison-based operations in a modular design, where each operation is implemented in a separate Verilog file. A top-level module (alu_top.v) integrates all submodules and selects the operation through a 3-bit opcode.

1.2 Scope and Functionality
Input/Output	Size	Description
A, B	4-bit	Operand inputs
opcode	3-bit	Operation selector
result	8-bit	Output of selected operation
carry_out	1-bit	Carry/Borrow/Flag output
Opcode	Operation	Description
000	ADD	Performs A + B
001	SUB	Performs A − B
010	MUL	Performs A × B (8-bit result)
011	DIV	Performs A ÷ B → {Remainder, Quotient}
100	NAND	Bitwise NAND between A and B
101	NOT	Bitwise NOT of A
110	CMP	Compare A and B (Equal, Greater, Less)
111	AVG	Calculates (A + B)/2
2. Design and Implementation
2.1 High-Level Architecture

The ALU consists of 8 independent modules computing all operations in parallel.
A 3-bit opcode multiplexer inside alu_top.v selects one result at a time.
The carry_out flag is used only for ADD and SUB operations.

Block Concept:

        ┌────────┐
   A ──▶│        │
   B ──▶│  ALU   │──▶ Result[7:0]
 Opcode─▶│ (Top) │──▶ Carry_Out
        └────────┘

2.2 Module Descriptions
Operation	Module	Process Description	Input	Output
Addition	add.v	Adds A and B. Produces 4-bit SUM + carry bit.	A[3:0], B[3:0]	SUM[3:0], COUT
Subtraction	sub.v	Subtracts B from A using 2’s complement logic. Borrow stored in COUT.	A[3:0], B[3:0]	DIFF[3:0], COUT
Multiplication	mul.v	Performs 4×4 multiplication → full 8-bit product.	A[3:0], B[3:0]	PRODUCT[7:0]
Division	div.v	Produces 4-bit quotient and 4-bit remainder combined as 8-bit output.	A[3:0], B[3:0]	OUT[7:0]
NAND	nand_g.v	Performs bitwise NAND and pads 8-bit result.	A[3:0], B[3:0]	Y[7:0]
NOT	not_g.v	Performs bitwise inversion of A.	A[3:0]	Y[7:0]
Comparator	cmp.v	Compares A and B → 1(Equal), 2(Greater), 4(Less).	A[3:0], B[3:0]	Y[7:0]
Average	avg.v	Adds A+B, shifts right by 1 → (A+B)/2.	A[3:0], B[3:0]	Y[7:0]
3. Verification Strategy (Testbench)
3.1 Methodology

A self-checking testbench (alu_tb.v) was developed to test all eight operations using directed test vectors.
It uses $display statements to show pass/fail status for each case.

3.2 Test Cases

Covers normal operations, overflow (ADD 15+1), underflow (SUB 1−15), division by zero, and boundary comparisons.

3.3 Testbench Overview

Simulates each opcode sequentially.

Displays time, opcode, operands, result, carry flag, and PASS/FAIL message.

Uses $dumpfile and $dumpvars for GTKWave waveform generation.

4. Simulation Results
4.1 Output Log (Example Snippet)
----------------------------------------------------------------------------------
| Time | OpCode | A | B | Result (Hex) | Result (Dec) | Carry | Expected Check |
----------------------------------------------------------------------------------
|   20 | 000 | C | 3 | 0000000F |  15 | 0 | PASS |
|   40 | 000 | F | 1 | 00000000 |   0 | 1 | PASS |
|   60 | 001 | F | 1 | 0000000E |  14 | 1 | PASS |
|   80 | 010 | A | 3 | 0000001E |  30 | 0 | PASS |
|  100 | 011 | D | 3 | 00010100 |  20 | 0 | PASS |
|  120 | 100 | A | 5 | 00001111 |  15 | 0 | PASS |
|  140 | 101 | A | 0 | 00000101 |   5 | 0 | PASS |
|  160 | 110 | 9 | 9 | 00000001 |   1 | 0 | PASS |
|  180 | 111 | A | 5 | 00000111 |   7 | 0 | PASS |
----------------------------------------------------------------------------------

4.2 Waveform Summary

ADD/SUB: Carry flag toggles on overflow/borrow.

MUL/DIV: 8-bit result correctly represents product and {remainder, quotient}.

NAND/NOT/CMP/AVG: Logical outputs validated per opcode behavior.

5. Conclusion

The 4-bit modular ALU was successfully designed and verified.
All eight operations passed simulation with correct results and flag behavior.
Future improvements can include signed arithmetic, overflow detection, and pipeline optimization for higher performance.
